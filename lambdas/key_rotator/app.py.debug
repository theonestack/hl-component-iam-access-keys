import boto3
import logging
import os
import json

logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):
    """
    Secrets Manager Rotation Template.
    Rotates a IAM access key in a secretsmanager secret.
    Args:
        event (dict): Lambda dictionary of event parameters. These keys must include the following:
            - SecretId: The secret ARN or identifier.
            - ClientRequestToken: The ClientRequestToken of the secret version.
            - Step: The rotation step (one of createSecret, setSecret, testSecret, or finishSecret).
        context (LambdaContext): The Lambda runtime information.
    Raises:
        ResourceNotFoundException: If the secret with the specified arn and stage does not exist.
        ValueError: If the secret is not properly configured for rotation.
        KeyError: If the event parameters do not contain the expected keys.
    """

    logger.info(f"The event: {event}")

    # ARN of secret in AWS Secret Manager.
    arn = event['SecretId']

    # Request token of AWS Secret Manager.
    token = event['ClientRequestToken']

    # First of rotation steps: [createSecret, setSecret, testSecret, finishSecret].
    step = event['Step']

    # Setup the client.
    service_client = boto3.client('secretsmanager')

    # Make sure the version is staged correctly.
    metadata = service_client.describe_secret(SecretId=arn)

    logger.info(f"The metadata: {metadata}")

    if not metadata['RotationEnabled']:
        logger.error(f"Secret {arn} is not enabled for rotation.")
        raise ValueError(f"Secret {arn} is not enabled for rotation.")

    versions = metadata['VersionIdsToStages']
    logger.info("Get the VersionIdsToStages:")
    logger.info(versions)

    if token not in versions:
        logger.error(f"Secret version {token} has no stage for rotation of secret {arn}.")
        raise ValueError(f"Secret version {token} has no stage for rotation of secret {arn}.")

    if "AWSCURRENT" in versions[token]:
        logger.info(f"Secret version {token} already set as AWSCURRENT for secret {arn}.")
        return
    elif "AWSPENDING" not in versions[token]:
        logger.error(f"Secret version {token} not set as AWSPENDING for rotation of secret {arn}.")
        raise ValueError(f"Secret version {token} not set as AWSPENDING for rotation of secret {arn}.")

    if step == "createSecret":
        create_secret(service_client, arn, token)
    elif step == "setSecret":
        set_secret(service_client, arn, token)
    elif step == "testSecret":
        test_secret(service_client, arn, token)
    elif step == "finishSecret":
        finish_secret(service_client, arn, token)
    else:
        raise ValueError("Invalid step parameter")

def create_secret(service_client, arn, token):
    """
    First stage in rotation lifecycle.
    Create the secret.
    Calls IAM to create a new access key and updates the secret wit the new secret key in a pending state.
    Adds the access key to the pending key tag on the secret.
    Args:
        service_client (client): The secrets manager service client.
        arn (string): The secret ARN or other identifier.
        token (string): The ClientRequestToken associated with the secret version.
    """

    logger.info("The create_secret function.")

    secret_dict = get_secret_dict(service_client, arn, token, "AWSCURRENT", required_fields=['User'])
    logger.info(f"The secret_dict value: {secret_dict}")

    iam_client = boto3.client('iam')
    username = secret_dict['User']

    # We need to check if there are 2 keys, if so we need to delete one before we can create the new key due to the resource limit.
    existing_access_keys = sorted(iam_client.list_access_keys(UserName=username)['AccessKeyMetadata'], key=lambda x: x['CreateDate'])
    logger.info(f"The existing_access_keys value: {existing_access_keys}")

    if len(existing_access_keys) >= 2:
        logger.info("At least 2 access keys already exist. Deleting the oldest version: %s." % existing_access_keys[0]['AccessKeyId'])
        iam_client.delete_access_key(UserName=username, AccessKeyId=existing_access_keys[0]['AccessKeyId'])

    # Make a copy of the secret_dict to update the secret.
    new_secret_dict = secret_dict.copy()

    # Create the new key.
    logger.info("Creating access key.")
    new_key = iam_client.create_access_key(UserName=username)
    new_secret_dict['AccessKeyId'] = new_key['AccessKey']['AccessKeyId']
    new_secret_dict['SecretAccessKey'] = new_key['AccessKey']['SecretAccessKey']
    logger.info(f"AccessKeyPair: {new_secret_dict['AccessKeyId']}, {new_secret_dict['SecretAccessKey']}")

    # Update the secret key id in the secret and set it to a pending state.
    logger.info("Storing to Secrets Manager.")

    response = service_client.put_secret_value(SecretId=arn, ClientRequestToken=token, SecretString=json.dumps(new_secret_dict), VersionStages=['AWSPENDING'])
    logger.info(f"The put_secret_value response: {response}")
    logger.info("Storing to Secrets Manager is done!")
    logger.info("The end of create_secret function.")

def set_secret(service_client, arn, token):
    """
    Second stage in rotation lifecycle.
    Set the secret.
    The IAM service sets the secret in the user so there is nothing to do here.
    Args:
        service_client (client): The secrets manager service client.
        arn (string): The secret ARN or other identifier.
        token (string): The ClientRequestToken associated with the secret version.
    """

    logging.info("Nothing to do here as IAM service itself sets the secret in the user.")

def test_secret(service_client, arn, token):
    """
    Third stage in rotation lifecycle.
    Test the secret.
    Tests the new IAM access key.
    Args:
        service_client (client): The secrets manager service client.
        arn (string): The secret ARN or other identifier.
        token (string): The ClientRequestToken associated with the secret version.
    """

    secret_dict = get_secret_dict(service_client, arn, token, "AWSPENDING", required_fields=['User','AccessKeyId','SecretAccessKey'])
    logger.info(f"Dict on get_secret_dict of testSecret step: {secret_dict}")

    # Try to get object.
    logger.info("Testing the authorization with AccessKeyId/SecretAccessKey.")
    test_client = boto3.client('iam', aws_access_key_id=secret_dict['AccessKeyId'], aws_secret_access_key=secret_dict['SecretAccessKey'])

    try:
        test_client.get_account_authorization_details()
        logger.info("Testing the secrets is successful.")
    except test_client.exceptions.ClientError as e:
        # The test fails if and only if Authentication fails. Authorization failures are acceptable.
        logger.info("Testing the secrets is failed.")
        if e.response['Error']['Code'] == 'AuthFailure':
            raise ValueError(f"Pending IAM secret {arn} in rotation {secret_dict['User']} failed the test to authenticate. Exception: {e}.")
    logger.info("Testing the secrets is done!")

def finish_secret(service_client, arn, token):
    """
    Fourth stage in rotation lifecycle.
    Finish the secret.
    This method finalizes the rotation process by marking the secret version passed in as the AWSCURRENT secret.
    Tags the secret with the new access key and removes the pending key tag.
    Args:
        service_client (client): The secrets manager service client.
        arn (string): The secret ARN or other identifier.
        token (string): The ClientRequestToken associated with the secret version.
    """

    logger.info("Start finishSecret step.")

    # First describe the secret to get the current version.
    secret = service_client.describe_secret(SecretId=arn)

    """
    The result can be like next:
	'VersionIdsToStages':
		{
		 '9fb8657a-942c-1ce2-8a50-9fed5adf7fd9': ['AWSCURRENT'],
		 'a3752430-c455-4fb6-9ea2-ac54151ff5bb': ['AWSPENDING']
		}
    Where the second one is the first AccessKey just created for the newly created USER.
    Where the first one is the non-existence AccessKey, i.e. when the USER was just created. In this case ClientRequestToken != VersionId.
    """
    logger.info(f"Get secret on finishSecret step: {secret}")
    logger.info(f"The arn on finishSecret step: {arn}")
    logger.info(f"The token on finishSecret step: {token}")

    current_version = None
    for version in secret["VersionIdsToStages"]:
        logger.info(f"Next one version: {version}")
        if "AWSCURRENT" in secret["VersionIdsToStages"][version]:
            if version == token:
                # The correct version is already marked as current, return
                logger.info(f"finishSecret: Version {version} already marked as AWSCURRENT for {arn}.")
                return
            current_version = version
            break

    # Get the user and the current access key so we can clean up the old one.
    logger.info("Get the user and the current access key so we can clean up the old one.")

    #######
    # !!! #
    #######
    try:
        secret_dict = get_secret_dict(service_client, arn, token, "AWSCURRENT", required_fields=['User','AccessKeyId'])
    except:
        # If we do not yet have any AccessKey for the newly created USER.
        secret_dict = get_secret_dict(service_client, arn, token, "AWSCURRENT", required_fields=['User'])
    logger.info(f"Get secret_dict on finishSecret step: {secret_dict}")

    # Finalize by staging the secret version current.
    logger.info("Finalize by staging the secret version current.")
    response = service_client.update_secret_version_stage(SecretId=arn, VersionStage="AWSCURRENT", MoveToVersionId=token, RemoveFromVersionId=current_version)
    logger.info(f"The response of update_secret_version_stage on finishSecret step: {response}")

    #######
    # !!! #
    #######
    # Cleanup the old access key.
    logger.info("Cleanup the old access key.")
    logger.info(f"Cleanup the User: {secret_dict['User']}")
    try:
        logger.info(f"Cleanup the AccessKeyId: {secret_dict['AccessKeyId']}.")
    except:
        logger.info("There are no any AccessKey yet.")

    try:
        logger.info("Cleanup the old access key now....")
        response = iam_client.delete_access_key(UserName=secret_dict['User'], AccessKeyId=secret_dict['AccessKeyId'])
        logger.info(f"The response of iam_client.delete_access_key on finishSecret step: {response}")
    except:
        pass

    logger.info(f"finishSecret: Successfully set AWSCURRENT stage to version {token} for secret {arn}.")
    logger.info("End finish step.")

def get_secret_dict(service_client, arn, token, stage, required_fields=[]):
    """
    Gets the secret dictionary corresponding for the secret arn, stage, and token.
    This helper function gets credentials for the arn and stage passed in and returns the dictionary by parsing the JSON string.
    Args:
        secretsmanager_client (client): The secrets manager service client.
        arn (string): The secret ARN or other identifier.
        token (string): The ClientRequestToken associated with the secret version, or None if no validation is desired.
        stage (string): The stage identifying the secret version.
    Returns:
        SecretDictionary: Secret dictionary.
    Raises:
        ResourceNotFoundException: If the secret with the specified arn and stage does not exist.
        ValueError: If the secret is not valid JSON.
        KeyError: If the secret json does not contain the expected keys.
    """

    logger.info("Function get_secret_dict.")

    logger.info(f"The token: {token}.")
    logger.info(f"The VersionStage: {stage}.")
    logger.info(f"The arn: {arn}.")

    #######
    # !!! #
    #######
    try:
        secret = service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage=stage)
    except:
        # If we do not yet have any AccessKey for the newly created USER.
        secret = service_client.get_secret_value(SecretId=arn, VersionStage=stage)

    logger.info(f"The secret: {secret}")

    plaintext = secret['SecretString']
    logger.info(f"The plaintext secret: {plaintext}")

    secret_dict = json.loads(plaintext)
    # Run validations against the secret.
    for field in required_fields:
        if field not in secret_dict:
            raise KeyError("%s key is missing from secret JSON" % field)
    # Parse and return the secret JSON string.
    logger.info(f"The secret_dict: {secret_dict}")
    logger.info("Function end of get_secret_dict function.")

    return secret_dict
